###########################################################
#       u2logScaleX
###########################################################
u2logScaleX <- function( u )
{
   return(if(par("xlog")){10^u}else{u})
}
###########################################################
#       u2logScaleY
###########################################################
u2logScaleY <- function( u )
{
   return(if(par("ylog")){10^u}else{u})
}
###########################################################
#       logScale2uX
###########################################################
logScale2uX <- function( x )
{
   return(if(par("xlog")){log10(x)}else{x})
}
###########################################################
#       logScale2uY
###########################################################
logScale2uY <- function( y )
{
   return(if(par("ylog")){log10(y)}else{y})
}
###########################################################
#       USR
###########################################################
#
# get the usr coordinate for the given index
# this function is needed when one or both of the axses
# are log
###########################################################
USR <- function(i)
{
   if( i == 1)
   {
      return(if(par("xlog")){10^par("usr")[1]}else{par("usr")[1]})
   }
   else if( i== 2 )
   {
      return(if(par("xlog")){10^par("usr")[2]}else{par("usr")[2]})
   }
   else if( i== 3 )
   {
      return(if(par("ylog")){10^par("usr")[3]}else{par("usr")[3]})
   }
   else if( i== 4 )
   {
      return(if(par("ylog")){10^par("usr")[4]}else{par("usr")[4]})
   }
   else
   {
      return ("USR unknown index i")
   }

}

###########################################################
#       translationMatrix
###########################################################
#
#    | 1  0  x |
#    | 0  1  y |
#    | 0  0  1 |
#
###########################################################
translationMatrix <- function(x,y)
{
   a = c(1,0,0,0,1,0,x,y,1)
   return (array(a,dim=c(3,3)))
}

###########################################################
#      rotationMatrix
###########################################################
#generate the Matrix
#
# | cos()  -sin()     0 |
# | sin()   cos()     0 |
# |   0       0       1 |
#
# argument must be in radians
###########################################################
rotationMatrix <- function(radians)
{
   a = c(cos(radians),sin(radians),0,
        -sin(radians),cos(radians),0,
              0,          0,       1)
   return (array(a,dim=c(3,3)))
}

###########################################################
#       deg2rad
###########################################################
#convert degrees into radians
###########################################################
deg2rad <- function(deg)
{
   return (pi*deg/180)
}

###########################################################
#              findRotation
###########################################################
# (x1,y1) first end pt of line
# (x2,y2) second end pt of line
findRotation <- function(x1,y1,x2,y2)
{
   v1 <- c(x1,y1,1)
   v2 <- c(x2,y2,1)
   q1 <- Nu2q() %*% v1
   q2 <- Nu2q() %*% v2
   return( rad2deg( atan((q2[2]-q1[2])/(q2[1]-q1[1])) ))
}

###########################################################
#       rad2deg
###########################################################
#convert radians into degrees 
###########################################################
rad2deg <- function(rad)
{
   return (rad * 180 / pi)
}

###########################################################
#      borderHeight
###########################################################
#generate the y coordinates of a correctly sized border
#about (0,0) in "usr" coordinates
###########################################################
borderHeight <-function(strHeight,percentTop,percentBot)
{
   yb <- strHeight*percentBot + strHeight/2
   yt <- strHeight*percentTop + strHeight/2
   return(c(-yb,-yb,yt,yt,-yb))
}

###########################################################
#      borderWidth
###########################################################
#generate the x coordinates of a correctly sized border
#about (0,0) in "usr" coordinates
###########################################################
borderWidth <-function(strW,chrW,percentLeft,percentRight)
{
   xl <- chrW*percentLeft + strW/2
   xr <- chrW*percentRight + strW/2
   return(c(-xl,xr,xr,-xl,-xl))
}

###########################################################
#             Nu2q
###########################################################
#Normalization matrix from "usr" to "pin" coordinates
###########################################################
Nu2q <- function()
{  
   u1 <- par("usr")[2]-par("usr")[1]
   u2 <- par("usr")[4]-par("usr")[3]
   q1 <- par("pin")[1]
   q2 <- par("pin")[2]
   sx <- q1/u1
   sy <- q2/u2
   a = c(sx,0,0,0,sy,0,-sx*par("usr")[1],-sy*par("usr")[3],1)
   return (array(a,dim=c(3,3)))
}  
   
###########################################################
#             Nq2u 
###########################################################
#Normalization matrix from "pin" to "usr" coordinates
###########################################################
Nq2u <- function()
{
   u1 <- par("usr")[2]-par("usr")[1]
   u2 <- par("usr")[4]-par("usr")[3]
   q1 <- par("pin")[1]
   q2 <- par("pin")[2]
   sx <- q1/u1
   sy <- q2/u2
   a = c(1/sx,0,0,0,1/sy,0,par("usr")[1],par("usr")[3],1)
   return (array(a,dim=c(3,3)))
}

###########################################################
#                     borderedText
###########################################################
# txt - text string to be bordered
# (x,y) - the center of the text string
# srt - rotation in degrees
# bcol - border color NULL=use par("fg") NA=omit border
# fcol - background color NA=do not fill
# rP - pad % of char width on right
# lP - pad % of char width on left
# bP - pad % of char height on bottom
# tP - pad % of char height on top
borderedText <- function(txt,x,y,srt,bcol,fcol,rP,lP,bP,tP)
{
   #if using log scale, then convert to linear usr coordinates
   x <- logScale2uX( x )
   y <- logScale2uY( y )

   #size the text border around (0,0)
   w <- strwidth(txt)
   wchar <- par("cex")*strwidth("X")
   h <- strheight(txt)
   xRecOld <- borderWidth(w,wchar,rP,lP)
   yRecOld <- borderHeight(h,bP,tP)

   #translate the border corner points to be centered
   #around the center of the text string
   xRec <- NULL
   yRec <- NULL
   tM <- translationMatrix(x,y)
   for(i in 1:5)
   {
      vOld <- c(xRecOld[i],yRecOld[i],1)
      vNew <-  tM %*% vOld
      xRec[i] = vNew[1]
      yRec[i] = vNew[2]
   }

   #convert the (x,y) center of the text into par("pin")
   #coordinates q is used to represent the par("pin")
   #coordinates
   q <- Nu2q() %*% c(x,y,1)

   #build matrix to translate the center of text in
   #par("pin") coordinates to the origin
   T1 <- translationMatrix(q[1],q[2])

   #the inverse translation of T1 above
   T2 <- translationMatrix(-q[1],-q[2])

   #build rotation matrix
   R <- rotationMatrix(deg2rad(srt))

   #for each corner point on the border
   #*convert from "usr" to "pin" coordinates
   #*translate to origin of "pin" coordinates
   #*rotate
   #*translate from origin back to center of text location
   #*convert from "pin" to "usr" coordinates
   xRot <- NULL
   yRot <- NULL
   for(i in 1:5)
   {
      v <- c(xRec[i],yRec[i],1)
      vNew <- Nq2u() %*% T1 %*% R %*% T2 %*% Nu2q() %*% v
      xRot[i] = vNew[1]
      yRot[i] = vNew[2]
   }

   #finally draw the text border and fill
   xlogSAVE <- par(xlog=FALSE)
   ylogSAVE <- par(ylog=FALSE)
   polygon(xRot,yRot,border = bcol,col=fcol)
   par(xlog=xlogSAVE)
   par(ylog=ylogSAVE)
}
###########################################################
#              positionText
###########################################################
# (x1,y1) first end pt of line
# (x2,y2) second end pt of line
# xj adjustment along the line
#    0 = (x1,y1)
#    1 = (x2,y2)
#  0.5 = ((x2+x1)/2,(y2+y1)/2)
# yj = adjustment above the line by "h" units
# h = usually the height of the text
positionText <- function(x1,y1,x2,y2,xj,yj,h)
{
   #if using log scale convert in linear usr coordinates
   x1 <- logScale2uX( x1 )
   x2 <- logScale2uX( x2 )
   y1 <- logScale2uY( y1 )
   y2 <- logScale2uY( y2 )

   #create a line of the proper length along the X-axis
   l <- sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))
   xo1 <- -l/2
   xo2 <-  l/2
   yo1 <- 0
   yo2 <- 0

   #position the text relative to the line on the X-axis
   pt <- c(xj*xo2 + xo1*(1 - xj),yj*h,1)

   #build rotation matrix
   R <- rotationMatrix(atan((y2-y1)/(x2-x1)))

   #build translation matrix to the center of the line
   xm <- (x2+x1)/2
   ym <- (y2+y1)/2
   T1 <- translationMatrix(xm,ym)

   #rotate and translate
   pt2 <- T1 %*% R %*% pt

   #if log scale then convert from linear usr coordinates 
   #into log
   xRtrn <- u2logScaleX( pt2[1] )
   yRtrn <- u2logScaleY( pt2[2] )

   return(c(xRtrn, yRtrn))
}
###########################################################
#         lineCategory
###########################################################
lineCategory <- function(x1,y1,x2,y2){
   p1bits<-pbits(x1,y1)
   p2bits<-pbits(x2,y2)
   if(identical(p1bits,c(FALSE,FALSE,FALSE,FALSE)) && identical(p2bits,c(FALSE,FALSE,FALSE,FALSE)))
   {
      return ("VISIBLE")
   }
   if( ! identical((p1bits & p2bits),c(FALSE,FALSE,FALSE,FALSE)) )
   {
      return ("NOT VISIBLE")
   }
   if(identical((p1bits & p2bits),c(FALSE,FALSE,FALSE,FALSE)))
   {
      return ("CANDIDATE FOR CLIPPING")
   }
   else
   {
      return ("ERROR")
   }
}
###########################################################
#             refLine
###########################################################
#
###########################################################
refLine <- function(x1,y1,x2,y2,m=NULL)
{
   if(!is.null(m))
   {
      if((m=="Inf")||(m=="-Inf"))
      {
         b <- "Inf"
      }  
      else
      {
         b <- y1 - m*x1
      }  
      if((b == "Inf") || (b == "-Inf"))
      {
         x1 <- x1
         x2 <- x1
         y1 <- USR(3)
         y2 <- USR(4)
         lines(c(x1,x2),c(y1,y2))
         return(c(x1,y1,x2,y2))
      }
      else if( m == 0)
      {
         #intersection with LHS of plot region
         xLHS <- USR(1)
         yLHS <- y1 + m*(xLHS - x1)
         #intersection with RHS of plot region
         xRHS <- USR(2)
         yRHS <- y1 + m*(xRHS - x1)
         x1 <- xLHS
         x2 <- xRHS
         y1 <- yLHS
         y2 <- yRHS
         lines(c(x1,x2),c(y1,y2))
         return(c(x1,y1,x2,y2))
      }
      else
      {
         #intersection with LHS of plot region
         xLHS <- USR(1)
         yLHS <- y1 + m*(xLHS - x1)
         #intersection with RHS of plot region
         xRHS <- USR(2)
         yRHS <- y1 + m*(xRHS - x1)
         x1 <- xLHS
         y1 <- yLHS
         x2 <- xRHS
         y2 <- yRHS
         for(i in 1:4)
         {
            l <- clip1(x1,y1,x2,y2)
            x1 = l[1]
            y1 = l[2]
            x2 = l[3]
            y2 = l[4]
            if(identical(lineCategory(x1,y1,x2,y2),"VISIBLE"))
            {
               lines(c(x1,x2),c(y1,y2))
               return(c(x1,y1,x2,y2))
            }
            else if(identical(lineCategory(x1,y1,x2,y2),"NOT VISIBLE"))
            {
               return(NULL)
            }
         }
      }
   }
   else
   {
      lines(c(x1,x2),c(y1,y2))
      return(c(x1,y1,x2,y2))
   }
}
###########################################################
###########################################################
clip1 <- function(x1,y1,x2,y2){

   p1bits<-pbits(x1,y1)
   p2bits<-pbits(x2,y2)
   x <- NULL
   y <- NULL
   m <- (y2-y1)/(x2-x1)
   if(p1bits[1])
   { #clip pt1 to Ymax
      y = USR(4)
      x = x1+(1/m)*(y-y1)
      return(c(x,y,x2,y2))
   }
   else if(p1bits[2])
   { #clip pt1 to Ymin
      y = USR(3)
      x = x1+(1/m)*(y-y1)
      return(c(x,y,x2,y2))
   }
   else if(p1bits[3])
   { #clip pt1 to Xmax
      x = USR(2)
      y = y1+m*(x-x1)
      return(c(x,y,x2,y2))
   }
   else if(p1bits[4])
   { #clip pt1 to Xmin
      x = USR(1)
      y = y1+m*(x-x1)
      return(c(x,y,x2,y2))
   }
   else if(p2bits[1])
   { #clip pt2 to Ymax
      y = USR(4)
      x = x1+(1/m)*(y-y1)
      return(c(x1,y1,x,y))
   }
   else if(p2bits[2])
   { #clip pt2 to Ymin
      y = USR(3)
      x = x1+(1/m)*(y-y1)
      return(c(x1,y1,x,y))
   }
   else if(p2bits[3])
   { #clip pt2 to Xmax
      x = USR(2)
      y = y1+m*(x-x1)
      return(c(x1,y1,x,y))
   }
   else if(p2bits[4])
   { #clip pt2 to Xmin
      x = USR(1)
      y = y1+m*(x-x1)
      return(c(x1,y1,x,y))
   }
   return(c(x1,y1,x2,y2))
}

###########################################################
###########################################################
pbits <- function(x,y){
   c(y>USR(4),y<USR(3),x>USR(2),x<USR(1))
}

###########################################################
###########################################################
newsPosition<-function(region,position,xjust,yjust)
{
   catn<-function(...)do.call("cat",c(lapply(list(...),formatC),list("\n")))
   ptslope<-function(x1,y1,x2,y2,x){slp<-(y2-y1)/(x2-x1);y1+slp*(x-x1)}
   fig<-c(
          figure<-ptslope(par("plt")[1],par("usr")[1],par("plt")[2],par("usr")[2],0),
          figure<-ptslope(par("plt")[1],par("usr")[1],par("plt")[2],par("usr")[2],1),
          figure<-ptslope(par("plt")[3],par("usr")[3],par("plt")[4],par("usr")[4],0),
          figure<-ptslope(par("plt")[3],par("usr")[3],par("plt")[4],par("usr")[4],1))
   center<-function(x1,x2,y1,y2,R,xjust,yjust)
   {
      w1<-(x2-x1)/3
      w2<-(y2-y1)/3
      Bx<-c( x1 , (x1+w1) , (x2-w1) , x2 )
      By<-c( y1 , (y1+w2) , (y2-w2) , y2 )
      rtrn <- "error"
      if(R=="NW")
      {
         x<-Bx[1]+(Bx[2]-Bx[1])*xjust
         y<-By[3]+(By[4]-By[3])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="N")
      {
         x<-Bx[2]+(Bx[3]-Bx[2])*xjust
         y<-By[3]+(By[4]-By[3])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="NE")
      {
         x<-Bx[3]+(Bx[4]-Bx[3])*xjust
         y<-By[3]+(By[4]-By[3])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="W")
      {
         x<-Bx[1]+(Bx[2]-Bx[1])*xjust
         y<-By[2]+(By[3]-By[2])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="C")
      {
         x<-Bx[1]+(Bx[4]-Bx[1])*xjust
         y<-By[1]+(By[4]-By[1])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="E")
      {
         x<-Bx[3]+(Bx[4]-Bx[3])*xjust
         y<-By[2]+(By[3]-By[2])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="SW")
      {
         x<-Bx[1]+(Bx[2]-Bx[1])*xjust
         y<-By[1]+(By[2]-By[1])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="S")
      {
         x<-Bx[2]+(Bx[3]-Bx[2])*xjust
         y<-By[1]+(By[2]-By[1])*yjust
         rtrn <- c(x,y)
      }
      else if(R=="SE")
      {
         x<-Bx[3]+(Bx[4]-Bx[3])*xjust
         y<-By[1]+(By[2]-By[1])*yjust
         rtrn <- c(x,y)
      }
   
      rtrn
   }
   if(region=="plot")
   {
      x1<-par("usr")[1]
      x2<-par("usr")[2]
      y1<-par("usr")[3]
      y2<-par("usr")[4]

   }
   else if(region=="maLeft")
   {
      x1<-fig[1]
      x2<-par("usr")[1]
      y1<-par("usr")[3]
      y2<-par("usr")[4]
   }
   else if(region=="maBot")
   {
      x1<-par("usr")[1]
      x2<-par("usr")[2]
      y1<-fig[3]
      y2<-par("usr")[3]
   }
   else if(region=="maTop")
   {
      x1<-par("usr")[1]
      x2<-par("usr")[2]
      y1<-par("usr")[4]
      y2<-fig[4]
   }
   else if(region=="maRight")
   {
      x1<-par("usr")[2]
      x2<-fig[2]
      y1<-par("usr")[3]
      y2<-par("usr")[4]
   }
   xy<-center(x1,x2,y1,y2,position,xjust,yjust)
   if(par("xlog")) { xy <- c(10^xy[1],xy[2]) }
   if(par("ylog")) { xy <- c(xy[1],10^xy[2]) }
   xy
}

###########################################################
###########################################################
logGrid<-function(side,min,max,interval)
{
  f1<-10^floor(min)
  c1<-10^ceiling(max)
  while(f1 <= c1)
  {
    for(j in c(1,seq(interval,10, by= interval)))
    {
      tick<-j*f1
      if((log10(tick)>=min)&&(log10(tick)<=max))
      {
        if(side == 1)
        {
          abline(v=tick);
        }
        if(side == 2)
        {
          abline(h=tick);
        }
      }
    }
    f1<-f1*10
  }
}

###########################################################
###########################################################
logTicks<-function(side,min,max,interval)
{
  f1<-10^floor(min)
  c1<-10^ceiling(max)
  while(f1 <= c1)
  {
    for(j in c(1,seq(interval,10, by= interval)))
    {
      tick<-j*f1
      if((log10(tick)>=min)&&(log10(tick)<=max))
      {
        axis(side,labels=FALSE,at=c(tick))
      }
    }
    f1<-f1*10
  }
}

###########################################################
###########################################################
BarPlotColumnNames <- function()
{
   DataColumnIndices <- grep(".*[^Label]$",variable.names(plotData))
   DataColumns <- variable.names((plotData)[DataColumnIndices])
   DataColumns 

}

###########################################################
###########################################################
BarPlotDataLabels <- function()
{  
   LabelColumnIndices <- grep(".*Label$",variable.names(plotData))
   Labels <- variable.names((plotData)[LabelColumnIndices])
   Labels
   
   LabelsAsName <- lapply(Labels,as.name)
   LabelsAsName
   
   x <- NULL
   for( i in 1:length(LabelsAsName))
   {
      x <- c(x,as.character(eval(LabelsAsName[[i]])))
   }
   x
   Levels <- levels(factor(x))
   Levels
}


###########################################################
# textBox
###########################################################
textBox <- function(x,y,txtStr,wrap=NULL,vSpace=0.25,xpd=NULL,cex=1,draw=TRUE,
 col="black",vfont=NULL,font=NULL,adj=c(0.5,0.5),offset=c(0.0,0.0),colFill=NULL,
 colBorder=NULL,lty=NULL,lwd=par("lwd"),pad=c(1.0,1,0,1.0,1.0),srt=0,justifyX=0.5,
 justifyY=0.5,
 MaxBoxWidth=NULL,MaxBoxHeight=NULL,absoluteWidth=NULL,absoluteHeight=NULL,
 indent=0,exdent=0)
{
print("============================================")
print("Entering: textBox")
print(paste("x <- ",x))
print(paste("y <- ",y))
print(paste("txtStr <- ",txtStr))
print(paste("wrap <- ",wrap))
print(paste("vSpace <- ",vSpace))
print(paste("xpd <- ",xpd))
print(paste("cex <- ",cex))
print(paste("draw <- ",draw))
print(paste("col <- ",col))
print(paste("vfont <- ",vfont))
print(paste("font <- ",font))
print(paste("adj <- ",adj))
print(paste("offset <- ",offset))
print(paste("colFill <- ",colFill))
print(paste("colBorder <- ",colBorder))
print(paste("lty <- ",lty))
print(paste("lwd <- ",lwd))
print(paste("pad <- ",pad))
print(paste("srt <- ",srt))
print(paste("justifyX <- ",justifyX))
print(paste("justifyY <- ",justifyY))
print(paste("MaxBoxWidth <- ",MaxBoxWidth))
print(paste("MaxBoxHeight <- ",MaxBoxHeight))
print(paste("absoluteWidth <- ",absoluteWidth))
print(paste("absoluteHeight <- ",absoluteHeight))

   if(!is.null(font))
   {
      par(font = font)
   }

   cex2 <- cex
   cexSave <- par("cex")

   #determine the character height
   chrHeight <- max(strheight(strsplit(txtStr,split="\n")))
   chrWidth <- strwidth("X")

   #if absoluteWidth and absoluteHeight are set the override 
   #MaxBoxWidth and MaxBoxHeight if they are set and also
   if( (!is.null(absoluteWidth)) && (!is.null(absoluteHeight)) )
   {
#      w <- absoluteWidth - (pad[1]+pad[3])*chrHeight
#      h <- absoluteHeight - (pad[2]+pad[4])*chrHeight
      #r <- TextBoxWrap(absoluteWidth,absoluteHeight,txtStr,cex,vSpace)
      #r <- TextBoxWrapFixedWH(absoluteWidth,absoluteHeight,txtStr,cex,vSpace)
      r <- TextBoxWrap(absoluteWidth,absoluteHeight,txtStr,cex,vSpace,wrap,indent,exdent,pad)
      wrap <- r[1]
print(paste("r[2]=",r[2]))
      par(cex = r[2])
      cex2 <- r[2]
   }
   else
   {
      #if MaxBoxWidth and MaxBoxHeight are selected then override wrap
      #fit and wrap text to fit within a box of size (w,h)
      if( (!is.null(MaxBoxWidth)) && (!is.null(MaxBoxHeight)) )
      {
#         w <- MaxBoxWidth - (pad[1]+pad[3])*chrHeight
#         h <- MaxBoxHeight - (pad[2]+pad[4])*chrHeight
         r <- TextBoxWrap(MaxBoxWidth,MaxBoxHeight,txtStr,cex,vSpace,wrap,indent,exdent,pad)
         wrap <- r[1]
         par(cex = r[2])
         cex2 <- r[2]
      }
   }

   #determine the character height
   chrHeight <- max(strheight(strsplit(txtStr,split="\n")))


   #set labels
   if(is.null(wrap))
   {
      #labels = txtStr
      tmp <- strsplit(txtStr,split="\n")[[1]]
      labels <- tmp
   }
   else
   {
      #labels = strwrap(txtStr,wrap)
      tmp <- strsplit(txtStr,split="\n")[[1]]
print("tmp")
print(tmp)
print(wrap)
print(paste("indent",indent))
print(paste("exdent",exdent))
      labels = strwrapAE(tmp,wrap,indent=indent,exdent=exdent)
print(labels)
   }

   #number of lines of text in the box
   numLines <- length(labels)

   #number of spacing lines in the box
   numSpaceLines = numLines - 1

   #box width and height
   if( (!is.null(absoluteWidth)) && (!is.null(absoluteHeight)) )
   {
      boxWidth <- absoluteWidth
      boxHeight <- absoluteHeight
   }
   else
   {
#5-27      boxWidth <- max(strwidth(labels)) + (pad[1]+pad[3])*chrHeight
      boxWidth <- max(strwidth(labels)) + (pad[1]+pad[3])*chrWidth
      boxHeight <- numLines*chrHeight + numSpaceLines*chrHeight*vSpace + (pad[2]+pad[4])*chrHeight
   }

   #initial positions
#   x0 <- logScale2uX( x )
#   y0 <- logScale2uY( y )
   x0 <-  x
   y0 <-  y
print(paste("x <- ",x))
print(paste("x0 <- ",x0))
print(paste("y <- ",y))
print(paste("y0 <- ",y0))

   #determine the bounds of the rectangle
print(paste("adj[1] <- ",adj[1]))
print(paste("adj[2] <- ",adj[2]))
print(paste("boxWidth <- ",boxWidth))
print(paste("boxHeight <- ",boxHeight))
   xleft <- x0 - adj[1]*boxWidth
   ybottom <- y0 + (adj[2] - 1)*boxHeight
   xright <- x0 + (1-adj[1])*boxWidth
   ytop <- y0 + adj[2]*boxHeight
print(paste("xleft <- ",xleft))
print(paste("ybottom <- ",ybottom))
print(paste("xright <- ",xright))
print(paste("ytop <- ",ytop))


   #offset
   tmpOffset <- offset
#5-27   xleft <- xleft + tmpOffset[1]*chrHeight
   xleft <- xleft + tmpOffset[1]*chrWidth
   ybottom <- ybottom + tmpOffset[2]*chrHeight
#5-27   xright <- xright + tmpOffset[1]*chrHeight
   xright <- xright + tmpOffset[1]*chrWidth
   ytop <- ytop + tmpOffset[2]*chrHeight

   #simplify the names
   l <- xleft
   b <- ybottom
   r <- xright
   t <- ytop

   #display the bounding rectangle
   if(draw)
   {
      rect(xleft=u2logScaleX( l ), ybottom=u2logScaleY( b ), xright=u2logScaleX( r ), ytop= u2logScaleY( t ), 
        col = colFill, border = colBorder, lty = lty, lwd = lwd, xpd = xpd)
   }
#5-27
   #generate the x1,y1 coordinates
#   x1 <- (1 - justifyX)*(l + pad[1]*chrHeight) + justifyX*(r - pad[3]*chrHeight)
#H <- ((numSpaceLines+1)+(numSpaceLines)*vSpace)*chrHeight
#TxtAreaH <- (t - pad[4]*chrHeight) -(b + pad[2]*chrHeight)
#TxtAreaCenter <- ((t - pad[4]*chrHeight) + (b + pad[2]*chrHeight))/2
#y1 <- TxtAreaCenter+(H/2) + (justifyY-0.5)*TxtAreaH - (justifyY-0.5)*H
##   y1 <- t - pad[4]*chrHeight
#   y1 <- y1 - (0:numSpaceLines)*chrHeight*(1.0 + vSpace)
#
   chrWidth <- strwidth("X")
   x1 <- (1 - justifyX)*(l + pad[1]*chrWidth) + justifyX*(r - pad[3]*chrWidth)
   H <- ((numSpaceLines+1)+(numSpaceLines)*vSpace)*chrHeight
   TxtAreaH <- (t - pad[4]*chrHeight) -(b + pad[2]*chrHeight)
   TxtAreaCenter <- ((t - pad[4]*chrHeight) + (b + pad[2]*chrHeight))/2
   y1 <- TxtAreaCenter+(H/2) + (justifyY-0.5)*TxtAreaH - (justifyY-0.5)*H
   y1 <- y1 - (0:numSpaceLines)*chrHeight*(1.0 + vSpace)
print("y1")
print(y1)
print(paste("t= " , t))
print(paste("b= " , b))
print(paste("par(cex)= " , par("cex")))
print(paste("chrHeight= " , chrHeight))

   #convert to log scale if needed
   x1 <- u2logScaleX( x1 )
   y1 <- u2logScaleY( y1 )

   #display the text
   if(draw)
   {
print(paste("cex2=",cex2))
print(paste("par(cex)=",par("cex")))
      text(xpd=xpd,srt=srt,cex=1,col=col,labels=labels,x=x1,y=y1,vfont=vfont,adj=c(justifyX,1))
   }
   par(cex = cexSave)

   #compass usr coordinates of box; useful for drawing arrows
   N  <- c((l+r)/2,t)
   NE <- c(r,t)
   E  <- c(r,(b+t)/2)
   SE <- c(r,b)
   S  <- c((l+r)/2 , b)
   SW <- c(l,b)
   W  <- c(l,(b+t)/2)
   NW <- c(l,t)

   return(list(N=N,NE=NE,E=E,SE=SE,S=S,SW=SW,W=W,NW=NW))
}

###########################################################
# textBoxArrows
###########################################################
textBoxArrows <- function(x1,y1,compass,compassSetting="N",
     length=0.25,angle=30,code=2,col=par("fg"),lty=NULL,
     lwd=par("lwd"),xpd=NULL,backoff=0)
{
print("============================================")
print("Entering: textBoxArrows")
print(paste("x1 <- ",x1))
print(paste("y1 <- ",y1))
print(paste("compass <- ",compass))
print(paste("compassSetting <- ",compassSetting))
print(paste("length <- ",length))
print(paste("angle <- ",angle))
print(paste("code <- ",code))
print(paste("col <- ",col))
print(paste("lty <- ",lty))
print(paste("lwd <- ",lwd))
print(paste("xpd <- ",xpd))
print(paste("backoff <- ",backoff))

   #compassSetting and x1,y1 could be an array; the number
   #of arrows = max(length(compassSetting),length(x1))
   for(i in 1:max(length(compassSetting),length(x1)))
   {
      #for the i-th compass setting we need to extract its correct (x,y)
      #coordinates from the list object "compass". "compass" has a structure of:
      #> str(compass)
      #List of 8
      #$ N : num [1:2] 12.28  8.58
      #$ NE: num [1:2] 14.00  8.58
      #$ E : num [1:2] 14.00  7.73
      #$ SE: num [1:2] 14.00  6.89
      #$ S : num [1:2] 12.28  6.89
      #$ SW: num [1:2] 10.57  6.89
      #$ W : num [1:2] 10.57  7.73
      #$ NW: num [1:2] 10.57  8.58
      #we need a way given a compassSetting say "SW" to extract the correct
      #(x,y) from "compass"
      #we use something similar to
      #tmp <- match(labels(compass),"SW")
      #> str(tmp)
      #int [1:8] NA NA NA NA NA 1 NA NA
      #given the structure of "tmp" we can loop over "tmp" until we find the "1"
      #
      tmp <- match(labels(compass),compassSetting[((i-1) %% length(compassSetting))+1])
      for(j in 1:length(tmp))
      {
         if(!is.na(tmp[j]))
         {
            X0 <- compass[[j]][1]
            Y0 <- compass[[j]][2]
         }
      }
      X1 <- logScale2uX( x1[((i-1) %% length(x1))+1] )
      Y1 <- logScale2uY( y1[((i-1) %% length(y1))+1] )
      l <- length[((i-1) %% length(length))+1]
      a <- angle[((i-1) %% length(angle))+1]
      code <- code[((i-1) %% length(code))+1]
      col <- col[((i-1) %% length(col))+1]
      lty <- lty[((i-1) %% length(lty))+1]
      lwd <- lwd[((i-1) %% length(lwd))+1]
      xpd <- xpd[((i-1) %% length(xpd))+1]


      #backoff from the end point
      r <- sqrt((X1-X0)*(X1-X0) + (Y1-Y0)*(Y1-Y0))
      theta = atan2((Y1-Y0),(X1-X0))
      r <- r - backoff[((i-1) %% length(backoff))+1]*strheight("X")
      X1p <- X0 + r * cos(theta)
      Y1p <- Y0 + r * sin(theta)

      arrows(u2logScaleX(X0), u2logScaleY(Y0), u2logScaleX(X1p), u2logScaleY(Y1p), length = l, angle = a, code = code,
       col = col, lty = lty, lwd = lwd, xpd = xpd)
   }
}

###########################################################
# TextBoxCeiling
###########################################################
TextBoxCeiling <- function(BoxW,txtStr,wrap)
{
print("TextBoxCeiling")
print(wrap)
   txtStr2 <- gsub("\n","",txtStr)
   nChar <- length(strsplit(txtStr2,split="")[[1]])
   width <- strwidth(txtStr)
   w <- floor(BoxW * (nChar/width))
   return(w)
}

###########################################################
# Nu2f - convert from user to figure coordinates
###########################################################
# Usage
#  Nu2f() %*% c(x,y,1)
Nu2f <- function()
{
   x1 <- par("usr")[1]
   x2 <- par("usr")[2]
   x3 <- par("usr")[3]
   x4 <- par("usr")[4]
   t1 <- par("plt")[1]
   t2 <- par("plt")[2]
   t3 <- par("plt")[3]
   t4 <- par("plt")[4]

   u1 <- x2 - x1
   u2 <- x4 - x3
   q1 <- t2 - t1
   q2 <- t4 - t3
   sx <- q1/u1
   sy <- q2/u2
   bx <- t1-(sx)*x1
   by <- t3-(sy)*x3
   a = c(sx,0,0,0,sy,0,bx,by,1)
   return (array(a,dim=c(3,3)))
}
###########################################################
# Nf2u - convert from figure to user coordinates
###########################################################
# Usage
#  Nf2u() %*% c(x,y,1)
Nf2u <- function()
{
   x1 <- par("plt")[1]
   x2 <- par("plt")[2]
   x3 <- par("plt")[3]
   x4 <- par("plt")[4]
   t1 <- par("usr")[1]
   t2 <- par("usr")[2]
   t3 <- par("usr")[3]
   t4 <- par("usr")[4]

   u1 <- x2 - x1
   u2 <- x4 - x3
   q1 <- t2 - t1
   q2 <- t4 - t3
   sx <- q1/u1
   sy <- q2/u2
   bx <- t1-(sx)*x1
   by <- t3-(sy)*x3
   a = c(sx,0,0,0,sy,0,bx,by,1)
   return (array(a,dim=c(3,3)))
}

###########################################################
# Nf2d - convert from figure to device coordinates
###########################################################
# Usage
#  Nf2d() %*% c(x,y,1)
Nf2d <- function()
{
   x1 <- 0
   x2 <- 1
   x3 <- 0
   x4 <- 1
   t1 <- par("fig")[1]
   t2 <- par("fig")[2]
   t3 <- par("fig")[3]
   t4 <- par("fig")[4]

   u1 <- x2 - x1
   u2 <- x4 - x3
   q1 <- t2 - t1
   q2 <- t4 - t3
   sx <- q1/u1
   sy <- q2/u2
   bx <- t1-(sx)*x1
   by <- t3-(sy)*x3
   a = c(sx,0,0,0,sy,0,bx,by,1)
   return (array(a,dim=c(3,3)))
}


###########################################################
# Nd2f - convert from device to figure coordinates
###########################################################
# Usage
#  Nd2f() %*% c(x,y,1)
Nd2f <- function()
{
   x1 <- par("fig")[1]
   x2 <- par("fig")[2]
   x3 <- par("fig")[3]
   x4 <- par("fig")[4]
   t1 <- 0
   t2 <- 1
   t3 <- 0
   t4 <- 1

   u1 <- x2 - x1
   u2 <- x4 - x3
   q1 <- t2 - t1
   q2 <- t4 - t3
   sx <- q1/u1
   sy <- q2/u2
   bx <- t1-(sx)*x1
   by <- t3-(sy)*x3
   a = c(sx,0,0,0,sy,0,bx,by,1)
   return (array(a,dim=c(3,3)))
}

###########################################################
# strwrapAE()
###########################################################

strwrapAE <- function(str,wrap=NULL,indent=0,exdent=0)
{
#print("strwrapAE - start")
#print("str")
#print(str)
   exdentString <- paste(rep(" ", exdent), collapse = "")
   labels <- strwrap(str,wrap,indent,exdent)
#print("labels1")
#print(labels)
   if((length(labels) > 1) && (NumChar(exdentString) > 0))
   {
      for(i in 2:length(labels))
      {
         labels[i] <- paste(exdentString,labels[i])
      }
   }
#print("labels2")
#print(labels)
#print("strwrapAE - end")
   return( labels )
}
###########################################################
# NEW STUFF
###########################################################




###########################################################
# TextBoxWrap
###########################################################
TextBoxWrap <- function(BoxW,BoxH,txtStr,cex,vSpace,Wrap,indent,exdent,pad)
{
print("Entering: TextBoxWrap(BoxW,BoxH,txtStr,cex,vSpace,Wrap,indent,exdent,pad)")
print("======================================================")
print(paste("BoxW= ", BoxW))
print(paste("BoxH= ", BoxH))
print(paste("txtStr= ", txtStr))
print(paste("cex= ", cex))
print(paste("vSpace= ", vSpace))
print(paste("Wrap= ", Wrap))
print(paste("indent= ", indent))
print(paste("exdent= ", exdent))
print(paste("pad= ", pad))
   cexSave <- par(cex=cex)

   if( ! is.null(Wrap))
   {
      cex <- FindCexGivenFixedWrap(BoxW,BoxH,txtStr,cex,vSpace,Wrap,indent,exdent,pad)
      return( c(Wrap, cex ))
   }
   else
   {
      rtrn <- FindCexAndWrap(BoxW,BoxH,txtStr,cex,vSpace,indent,exdent,pad)
      return ( rtrn )
   }
}
###########################################################
# 
###########################################################
NumChar <- function(txtStr)
{
   tmp <- strsplit(txtStr,split="")
   a <- 0
   for(i in 1:length(tmp) )
   {
      a[i] <- length(tmp[[i]])
   }
   return(a)
}
###########################################################
# 
###########################################################
FindCexAndWrap <- function(BoxW,BoxH,txtStr,cex,vSpace,indent,exdent,pad)
{
print("Entering: FindCexAndWrap")
print("================================================")
print(paste("BoxW <- ",BoxW))
print(paste("BoxH <- ",BoxH))
print(paste("txtStr <- ",txtStr))
print(paste("cex <- ",cex))
print(paste("vSpace <- ",vSpace))
print(paste("indent <- ",indent))
print(paste("exdent <- ",exdent))
print(paste("pad <- ",pad))
   cexStep <- 0.99
   cexSAVE <- par(cex=cex)
   cexARRAY <- cexArray(cex) 
   cexIndx = 1
   labels1 <- strsplit(txtStr,split="\n")[[1]] #broken at \n characters
   nChar <- length(strsplit(gsub("\n","",txtStr),split="")[[1]])+2
   labels2 <- strwrapAE(labels1,nChar,indent=indent,exdent=exdent)
   wrapArray <- sort(NumChar(labels2),decreasing=TRUE) +2
   wrapMax <- wrapArray[1]
   print(labels2)
   print(wrapMax)

   labels3 <- strwrapAE(labels1,1,indent=indent,exdent=exdent)
   wrapArray <- sort(NumChar(labels3),decreasing=TRUE) +2
   wrapStep <- wrapArray[length(wrapArray)]
   print(paste("wrapStep= ",wrapStep))

   done <- FALSE
   while( ! done )
   {
      wrap <- wrapMax
      labels2 <- strwrapAE(labels1,wrap,indent=indent,exdent=exdent)
      W <- TextBoxWH(labels2,vSpace)[1]
      H <- TextBoxWH(labels2,vSpace)[2]
print(paste("par(cex) = ",par("cex")))
print(paste("wrap = ",wrap))
print(paste("W= ",TextBoxWH(labels2,vSpace)[1]," BoxW= ",BoxW))
print(paste("H= ",TextBoxWH(labels2,vSpace)[2]," BoxH= ",BoxH))
      while( (wrap > 1 ) && (! TextBoxFitOK(labels2,BoxW,BoxH,pad,vSpace)))
      {
         wrap <- wrap - wrapStep
         labels2 <- strwrapAE(labels1,wrap,indent=indent,exdent=exdent)
         W <- TextBoxWH(labels2,vSpace)[1]
         H <- TextBoxWH(labels2,vSpace)[2]
print(paste("wrap = ",wrap))
print(paste("W= ",TextBoxWH(labels2,vSpace)[1]," BoxW= ",BoxW))
print(paste("H= ",TextBoxWH(labels2,vSpace)[2]," BoxH= ",BoxH))
      }

      if(TextBoxFitOK(labels2,BoxW,BoxH,pad,vSpace))
      {
         done <- TRUE
print(paste("done <- TRUE"))
print(paste("W= ",TextBoxWH(labels2,vSpace)[1]))
print(paste("H= ",TextBoxWH(labels2,vSpace)[2]))
print(paste("BoxW = ",BoxW))
print(paste("BoxH = ",BoxH))
print(paste("TextBoxFitOK = ",TextBoxFitOK(labels2,BoxW,BoxH,pad,vSpace)))
      }
      else
      {
#         par(cex=par("cex")*cexStep)
         cexIndx = cexIndx + 1
         par(cex=cexARRAY[cexIndx])
      }
   }
   return( c(wrap,par("cex")))
}
###########################################################
# 
###########################################################
FindCexGivenFixedWrap <- function(BoxW,BoxH,txtStr,cex,vSpace,Wrap,indent,exdent,pad)
{
print("Entering: FindCexGivenFixedWrap(BoxW,BoxH,txtStr,cex,vSpace,Wrap,indent,exdent,pad)")
print(paste("BoxW <- ",BoxW))
print(paste("BoxH <- ",BoxH))
print(paste("txtStr <- ",txtStr))
print(paste("cex <- ",cex))
print(paste("vSpace <- ",vSpace))
print(paste("Wrap <- ",Wrap))
print(paste("indent <- ",indent))
print(paste("exdent <- ",exdent))
print(paste("pad <- ",pad))
   cex2 <- cex
   labels1 <- strsplit(txtStr,split="\n")[[1]] #broken at \n characters
   labels2 <- strwrapAE(labels1,Wrap,indent=indent,exdent=exdent)

   #compute txt width
   W <- TextBoxWH(labels2,vSpace)[1]
  
   if( W > MaxTextBoxWH(labels2,BoxW,BoxH,pad)[1] )
   {
      cex2 <- cex2 * ( MaxTextBoxWH(labels2,BoxW,BoxH,pad)[1] /W )
print(paste("cex2 <- ",cex2))
print(paste("W <- ",W))
print(paste("MaxTextBoxWH(labels2,BoxW,BoxH,pad)[1] <- ",MaxTextBoxWH(labels2,BoxW,BoxH,pad)[1]))
      par(cex=cex2)
   }

   #compute txt height
   H <- TextBoxWH(labels2,vSpace)[2]

   if( H > MaxTextBoxWH(labels2,BoxW,BoxH,pad)[2] )
   {
      cex2 <- cex2 * ( MaxTextBoxWH(labels2,BoxW,BoxH,pad)[2] /H )
      par(cex=cex2)
   }
   return( cex2 )
}
###########################################################
# 
###########################################################
TextBoxFitOK <- function(labels,BoxW,BoxH,pad,vSpace)
{
   ok <- FALSE
   maxBoxWH <- MaxTextBoxWH(labels,BoxW,BoxH,pad)
   txtBoxWH <- TextBoxWH(labels,vSpace)
   if( (txtBoxWH[1] <= maxBoxWH[1]) && (txtBoxWH[2] <= maxBoxWH[2]) )
   {
      ok <- TRUE
   }
   return( ok )
}
###########################################################
# 
###########################################################
TextBoxWH <- function(labels,vSpace)
{
   #compute txt width
   W <- max(strwidth(labels))

   #compute txt height
   N <- length(labels)
   maxheight <- max(strheight(labels))
   H <- maxheight * (N + vSpace*(N-1))

   return( c(W,H) )
}
###########################################################
# 
###########################################################
MaxTextBoxWH <- function(labels,BoxW,BoxH,pad)
{
print("Entering: MaxTextBoxWH(labels,BoxW,BoxH,pad)")
print(paste("labels <- ",labels))
print(paste("BoxW <- ",BoxW))
print(paste("BoxH <- ",BoxH))
print(paste("pad <- ",pad))
   chrHeight <- max(strheight(labels))
print(paste("chrHeight <- ",chrHeight))
   chrWidth <- strwidth("X")
print(paste("chrWidth <- ",chrWidth))

   #compute text box width 
   txtBoxW <- BoxW - (pad[1]+pad[3])*chrWidth
print(paste("txtBoxW <- ",txtBoxW))

   #compute text box height
   txtBoxH <- BoxH - (pad[2]+pad[4])*chrHeight
print(paste("txtBoxH <- ",txtBoxH))

   return( c(txtBoxW,txtBoxH) )
}
###########################################################
# 
###########################################################
MaxNumChar <- function(txtStr)
{
   tmp <- strsplit(txtStr,split="")
   maxNumChar <- 0
   for(i in 1:length(tmp) )
   {
      maxNumChar <- max(maxNumChar,length(tmp[[i]]))
   }
   return(maxNumChar)
}
###########################################################
# 
###########################################################
cexArray <- function(cexStart)
{
   CEXarray <- c(20.0,19.8,19.7,19.5,19.3,19.2,19.0,18.8,18.7,18.5,18.3,18.2,18.0,17.8,17.7,
   17.5,17.3,17.2,17.0,16.8,16.7,16.5,16.3,16.2,16.0,15.8,15.7,15.5,15.3,15.2,
   15.0,14.8,14.7,14.5,14.3,14.2,14.0,13.8,13.7,13.5,13.3,13.2,13.0,12.8,12.7,
   12.5,12.3,12.2,12.0,11.8,11.7,11.5,11.3,11.2,11.0,10.8,10.7,10.5,10.3,10.2,
   10.0,9.8,9.7,9.5,9.3,9.2,9.0,8.8,8.7,8.5,8.3,8.2,8.0,7.8,7.7,
   7.5,7.3,7.2,7.0,6.8,6.7,6.5,6.3,6.2,6.0,5.8,5.7,5.5,5.3,5.2,
   5.0,4.8,4.7,4.5,4.3,4.2,4.0,3.8,3.7,3.5,3.3,3.2,3.0,2.8,2.7,
   2.5,2.3,2.2,2.0,1.8,1.7,1.5,1.3,1.2,1.0,0.8,0.7,0.6,0.3,0.2)
   if(cexStart>20)
   {
      tmp <- seq(cexStart,20,by=-0.1)
      CEXarray <- c(tmp,CEXarray)
   }
   return(subset(CEXarray,CEXarray<=cexStart))
}
###########################################################
# bxPrep - make sure the upper  and lower whiskers are set
# for each box plot; bx will not plot with the upper and
# lower whiskers set but the user may not have set the 
# whiskers or may not want whiskers
###########################################################
bxPrep <- function(bx)
{
   for(i in 1:dim(bx$stats)[2])
   {
      if(is.na(bx$stats[1,i]))
      {
         #if the lower whisker is NA then set it to equal
         #the lower hinge
         bx$stats[1,i] = bx$stats[2,i]
      }
      if(is.na(bx$stats[5,i]))
      {
         #if the upper whisker is NA then set it to equal
         #the upper hinge
         bx$stats[5,i] = bx$stats[4,i]
      }
   }
   return(bx)
}

###########################################################
#
###########################################################
findFirstTimeStamp <- function(ts)
{
   for(i in 1:length(ts))
   {
      if( !is.na(ts[i]) )
      {
         return( ts[i] )
      }
   }
}

###########################################################
#
###########################################################
findLastTimeStamp <- function(ts)
{
   for(i in length(ts):1)
   {
      if( !is.na(ts[i]) )
      {
         return( ts[i] )
      }
   }
}

###########################################################
#
###########################################################
findEarliestTimeStamp <- function(plotDataNames,plotDataTimeStampIndices)
{
   mn <- NULL
   mx <- NULL
   for(i in 1:length(plotDataTimeStampIndices))
   {
      x <- findFirstTimeStamp(eval(as.name(plotDataNames[plotDataTimeStampIndices[i]])))
      mn <- c(mn,x);
      x <- findLastTimeStamp(eval(as.name(plotDataNames[plotDataTimeStampIndices[i]])))
      mx <- c(mx,x);
   }
   return( c(min(type.convert(mn)),max(type.convert(mx))) );
}

###########################################################
#
###########################################################
normalizeTS <- function(ts,U1,U2,world1,world2)
{
   m <- (U2 - U1)/(world2 - world1)
   for(i in length(eval(ts)):1)
   {
      if( !is.na((eval(ts))[i]) )
      {
#         print(ts[i])
#         print(date2user(ts[i]))
         (eval(ts))[i] <- date2user(eval(ts)[i])
      }
   }
}

###########################################################
#
###########################################################
date2user <- function(date)
{
   m <- (U2 - U1)/(world2 - world1)
   return (U1 + m * (date - world1))
}

###########################################################
#
###########################################################
normalizeTimeStamps <- function(plotData,U1,U2,world1,world2)
{
print("0")
   plotDataNames <- variable.names(plotData)
print("1")
   numPlotDataNames <- length(plotDataNames)
print("2")
   plotDataTimeStampIndices <- grep(".*TimeStamp",plotDataNames)
print("3")
   if( length(plotDataTimeStampIndices) > 0)
   {
print("4")
      timeStampMinMax <- findEarliestTimeStamp(plotDataNames,plotDataTimeStampIndices)
print("5")
      if( is.null(world1) )
      {
         world1 <- timeStampMinMax[1]
      }
      if( is.null(world2) )
      {
         world2 <- timeStampMinMax[2]
      }
      print(world1)
      print(world2)
      world1 <<- world1
      world2 <<- world2
#      for(i in 1:length(plotDataTimeStampIndices))
#      {
#         name <- as.name(plotDataNames[plotDataTimeStampIndices[i]])
#         normalizeTS(name,U1,U2,world1,world2)
#      }
   }
}



###########################################################
# myBarPlot
###########################################################
# mx - position matrix returned from barplot
# cv - color vector
# zv - border color vector
# cp - color permutation matrix
# hx - height matrix
# wv - width vector
# sv - space vector
# hz - horizontal flag
# dv - density vector for shading
# av - angle vector for shading
# tv - lty vector
# lv - lwd vector
# xl - x limit vector
# yl - y limit vector
# pt - plot flag
# lg - log flag
# bs - beside flag (TRUE=nonstacked; FALSE=stacked)
# sd - categories span data sets
# b1 - lty vector for border
# b2 - lwd vector for border
###########################################################
myBarPlot <- function(xl,yl,cv,zv,cp,hx,wv,sv,hz,dv,av,tv,lv,pt,lg,bs,sd,b1,b2)
{  
   #=======================================================
   #if categories span data sets, then transpose the height
   #and color permuation matrices
   #
   if(sd)
   {
      hx <- t( hx )
      cp <- t( cp )
   }

   #=======================================================
   #call barplot() to position the bars
   #
   an <- FALSE
   ax <- NULL
   sv2 <- sv
   if((!is.null(sv))&&(dim(hx)[1] == 1))
   {
      sv2 <- c(sv[1])
   }

   if(dim(hx)[1] == 1)
   {
     mx<-barplot(height=hx,ann=an,axes=ax,horiz=hz,width=wv,space=sv2,beside=FALSE,plot=FALSE)
     mx <- t(matrix(mx))
   } else
   {
     mx<-barplot(height=hx,ann=an,axes=ax,horiz=hz,width=wv,space=sv2,beside=bs,plot=FALSE)
   }
   
   #=======================================================
   #determine the x axis limits
   #
   xl2 <- BarPlotXL(xl,mx)

   #=======================================================
   #determine the y axis limits
   #
   yl <- BarPlotYL(yl,hx,bs,lg)

   #=======================================================
   #set up the plotting area
   #
   BarPlotSetup(lg,hz,xl2,yl)

   #=======================================================
   #draw bars
   #
   BarPlotRect(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv,sd,b1,b2)

   return( mx )
}
###########################################################
# BarPlotSetup
###########################################################
# lg - log flag
# hz - horizontal flag
# xl - x limit vector
# yl - y limit vector
#
BarPlotSetup <- function(lg,hz,xl,yl)
{
   f <- FALSE
   if(lg)
   {
      if( hz )
      {
         #=================================================
         #horizontal log plot - interchange the xl & yl limits
         #
         matplot(add=f,ann=f,axes=f,type="n",x=yl,y=xl,log="x")
      } else
      {
         #=================================================
         #vertical log plot
         #
         matplot(add=f,ann=f,axes=f,type="n",x=xl,y=yl,log="y")
      }
   } else
   {
      if( hz )
      {
         #=================================================
         #horizontal plot - interchange the xl & yl limits
         #
         matplot(add=f,ann=f,axes=f,type="n",x=yl,y=xl)
      } else
      {
         #=================================================
         #vertical log plot
         #
         matplot(add=f,ann=f,axes=f,type="n",x=xl,y=yl)
      }
   }
}

   
###########################################################
# BarPlotXL
###########################################################
# xl - x limit vector
# mx - position matrix returned from barplot
#
BarPlotXL <- function(xl,mx)
{
   if(is.null(xl))
   {  
      xl2 <- c(0,max(mx) + min(mx))
   } else
   {
      tmp <- max(mx)-min(mx)
      xl2 <- c(tmp*xl[1]+min(mx) , tmp*xl[2]+max(mx))
   }
   return( xl2 )
}

###########################################################
# BarPlotYL
###########################################################
# xl - x limit vector
# hx - height matrix
# bs - beside flag (TRUE=nonstacked; FALSE=stacked)
# lg - log flag
#
BarPlotYL <- function(yl,hx,bs,lg)
{
   if(is.null(yl))
   {
      if(bs)
      {
         if(lg)
         {
            yl <- c(min(hx,na.rm=TRUE), max(hx,na.rm=TRUE) )
         } else
         {
            yl <- c(min(0,min(hx,na.rm=TRUE)), max(hx,na.rm=TRUE) )
         }
      } else
      {
         tmp <- sum(hx[,1],na.rm=TRUE)
         for(i in 2:dim(hx)[2])
         {
            tmp <- c(tmp,sum(hx[,i],na.rm=TRUE))
            print(tmp)
         }
         yl <- c(min(0,min(hx,na.rm=TRUE)), max(tmp) )
      }
   }
   return( yl )
}

###########################################################
# BarPlotRectNonStacked
###########################################################
# mx - position matrix returned from barplot
# cv - color vector
# cp - color permutation matrix
# hx - height matrix
# wv - width vector
# hz - horizontal flag
# bs - besides flag
# dv - density vector for shading
# av - angle vector for shading
# tv - lty vector
# lv - lwd vector
# zv - border color vector
# sd - categories span data sets
# b1 - lty vector for border
# b2 - lwd vector for border
###########################################################
BarPlotRectNonStacked <- function(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv,sd,b1,b2)
{
print(paste("dv <- ",dv))
print(paste("av <- ",av))
print(paste("tv <- ",tv))
print(paste("lv <- ",lv))
      for(i in 1:dim(mx)[1])
      {
         for(j in 1:dim(mx)[2])
         {
            p <- mx[i,j]
            #######c <- cv[(cp[i,j]-1)%%(length(cv)) +1]
            #if categories span data sets (sd == TRUE), then use the data set
            #index to determine the color. Otherwise use the cp
            if( sd )
            {
               c <- cv[(i-1)%%(length(cv)) +1]
            } else
            {
               c <- cv[(cp[i,j]-1)%%(length(cv)) +1]
            }
            d <- dv[(cp[i,j]-1)%%(length(dv)) +1]
            a <- av[(cp[i,j]-1)%%(length(av)) +1]
            t <- tv[(cp[i,j]-1)%%(length(tv)) +1]
            l <- lv[(cp[i,j]-1)%%(length(lv)) +1]
            z <- zv[(cp[i,j]-1)%%(length(zv)) +1]
            b <- b1[(cp[i,j]-1)%%(length(b1)) +1]
            e <- b2[(cp[i,j]-1)%%(length(b2)) +1]
            h <- hx[i,j]
            w <- wv[(i+j*dim(mx)[1]-1)%%(length(wv)) +1]
            x1 <- p-w/2
            y1 <- 0
            if( par("ylog") )
            {
               y1 <- u2logScaleY(par("usr")[3])
            }
            if( par("xlog") )
            {
               y1 <- u2logScaleX(par("usr")[1])
            }
            x2 <- p+w/2
            y2 <- h
            if(! is.na(h))
            {
print(paste("x1 <- ",x1))
print(paste("x2 <- ",x2))
print(paste("y1 <- ",y1))
print(paste("y2 <- ",y2))
print(paste("c <- ",c))
print(paste("d <- ",d))
print(paste("a <- ",a))
print(paste("t <- ",t))
print(paste("l <- ",l))
print(paste("b <- ",b))
print(paste("e <- ",e))
print(paste("z <- ",z))

               if( !hz )
               {
#print("rect(x1,y1,x2,y2,col=c,density=d,angle=a,border=z,lty=t,lwd = l)")
#                  rect(x1,y1,x2,y2,col=c,density=d,
#                     angle=a,border=z,lty=t,lwd = l)
#                  rect(x1,y1,x2,y2,col=NULL,density=NULL,
#                     angle=a,border=TRUE,lty=1,lwd = l)

                  if( is.null(density) )
                  {
                     rect(x1,y1,x2,y2,col=c,border=z,lty=b,lwd = e)
                  } else
                  {
                     rect(x1,y1,x2,y2,col=c,density=d,angle=a,border=FALSE,lty=t,lwd = l)
                     rect(x1,y1,x2,y2,col=NULL,border=z,lty=b,lwd = e)
                  }
               } else
               {
#print("rect(y1,x1,y2,x2,col=c,density=d,angle=a,border=z,lty=t,lwd = l)")
#                  rect(y1,x1,y2,x2,col=c,density=d,
#                     angle=a,border=z,lty=t,lwd = l)
                  if( is.null(density) )
                  {
                     rect(y1,x1,y2,x2,col=c,border=z,lty=b,lwd = e)
                  } else
                  {
                     rect(y1,x1,y2,x2,col=c,density=d,angle=a,border=FALSE,lty=t,lwd = l)
                     rect(y1,x1,y2,x2,col=NULL,border=z,lty=b,lwd = e)
                  }

               }
            }

         }
      }
}


###########################################################
# BarPlotRectStacked
###########################################################
# mx - position matrix returned from barplot
# cv - color vector
# cp - color permutation matrix
# hx - height matrix
# wv - width vector
# hz - horizontal flag
# dv - density vector for shading
# av - angle vector for shading
# tv - lty vector
# lv - lwd vector
# sd - categories span data sets
# b1 - lty vector for border
# b2 - lwd vector for border
###########################################################
BarPlotRectStacked <- function(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv,sd,b1,b2)
{
print("=================================================================")
print(paste("Entered: BarPlotRectStacked(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv)"))
print("mx <- "); print(mx)
print("cv <- "); print(cv)
print("cp <- "); print(cp)
print("dim(hx) <- "); print(dim(hx))
print("dim(cp) <- "); print(dim(cp))
print("hx <- "); print(hx)
print("wv <- "); print(wv)
print(paste("hz <- ",hz))
print(paste("bs <- ",bs))
print("dv <- "); print(dv)
print("av <- "); print(av)
print("tv <- "); print(tv)
print("lv <- "); print(lv)
print("zv <- "); print(zv)
   for(j in 1:dim(hx)[2])
   {
      y3 <- 0
      if( (hz) && par("xlog") )
      {
         y3 <- par("usr")[1]
         y3 <- u2logScaleX(y3)
      } else if( (!hz) && par("ylog") )
      {
         y3 <- par("usr")[3]
         y3 <- u2logScaleY(y3)
      }
      for(i in 1:dim(hx)[1])
      {
         p <- mx[j]
print(paste("i <- ",i))
print(paste("j <- ",j))
print(paste("(cp[i,j]-1)%%(length(cv)) +1 =  ",(cp[i,j]-1)%%(length(cv)) +1))
         #if categories span data sets (sd == TRUE), then use the data set
         #index to determine the color. Otherwise use the cp
         if( sd )
         {
            c <- cv[(i-1)%%(length(cv)) +1]
         } else
         {
            c <- cv[(cp[i,j]-1)%%(length(cv)) +1]
         }
         d <- dv[(cp[i,j]-1)%%(length(dv)) +1]
         a <- av[(cp[i,j]-1)%%(length(av)) +1]
         t <- tv[(cp[i,j]-1)%%(length(tv)) +1]
         l <- lv[(cp[i,j]-1)%%(length(lv)) +1]
         z <- zv[(cp[i,j]-1)%%(length(zv)) +1]
         b <- b1[(cp[i,j]-1)%%(length(b1)) +1]
         e <- b2[(cp[i,j]-1)%%(length(b2)) +1]
         h <- hx[i,j]
         w <- wv[(i+j*dim(cp)[1]-1)%%(length(wv)) +1]
print(paste("w <- ",w))
print(paste("p <- ",p))
         x1 <- p-w/2
         #y1 <- u2logScaleY(y3 + 0)
         y1 <- y3 + 0
         x2 <- p+w/2
         #y2 <- u2logScaleY(y1 + h)
         #y3 <- logScale2uY(y2)
         y2 <- y1 + h
         y3 <- y2
         if(! is.na(h))
         {
            if( !hz )
            {
print(paste("x1 <- ",x1))
print(paste("x2 <- ",x2))
print(paste("y1 <- ",y1))
print(paste("y2 <- ",y2))
print(paste("c <- ",c))
print(paste("d <- ",d))
print(paste("a <- ",a))
print(paste("z <- ",z))
print(paste("t <- ",t))
print(paste("l <- ",l))
print(paste("b <- ",b))
print(paste("e <- ",e))
print(paste("z <- ",z))
#print(paste("rect(x1,y1,x2,y2,col=c,density=d,angle=a,border=z,lty=t,lwd = l)"))
#               rect(x1,y1,x2,y2,col=c,density=d,
#                  angle=a,border=z,lty=t,lwd = l)
                  if( is.null(density) )
                  {
                     rect(x1,y1,x2,y2,col=c,border=z,lty=b,lwd = e)
                  } else
                  {
                     rect(x1,y1,x2,y2,col=c,density=d,angle=a,border=FALSE,lty=t,lwd = l)
                     rect(x1,y1,x2,y2,col=NULL,border=z,lty=b,lwd = e)
                  }

            } else
            {
#               rect(y1,x1,y2,x2,col=c,density=d,
#                  angle=a,border=z,lty=t,lwd = l)
                  if( is.null(density) )
                  {
                     rect(y1,x1,y2,x2,col=c,border=z,lty=b,lwd = e)
                  } else
                  {
                     rect(y1,x1,y2,x2,col=c,density=d,angle=a,border=FALSE,lty=t,lwd = l)
                     rect(y1,x1,y2,x2,col=NULL,border=z,lty=b,lwd = e)
                  }
            }
         }
      }
   }
}


###########################################################
# BarPlotRect
###########################################################
# mx - position matrix returned from barplot
# cv - color vector
# cp - color permutation matrix
# hx - height matrix
# wv - width vector
# hz - horizontal flag
# bs - beside flag (TRUE->nonstacked; FALSE->stacked)
# dv - density vector for shading
# av - angle vector for shading
# tv - lty vector
# lv - lwd vector
# zv - border color vector
# sd - categories span data sets
# b1 - lty vector for border
# b2 - lwd vector for border
###########################################################
BarPlotRect <- function(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv,sd,b1,b2)
{

   if( bs )
   {
      BarPlotRectNonStacked(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv,sd,b1,b2)
   } else
   {
      BarPlotRectStacked(mx,cv,cp,hx,wv,hz,bs,dv,av,tv,lv,zv,sd,b1,b2)
   }
}
###########################################################
# BoxHeight
###########################################################
BarHeightX <- function(alphaSort=F)
{     
         
   LabelColumnIndices <- grep(".*Label$",variable.names(plotData))
   Labels <- variable.names((plotData)[LabelColumnIndices])
   Labels
   
   LabelsAsName <- lapply(Labels,as.name)
   LabelsAsName

   DataColumnIndices <- grep(".*[^Label]$",variable.names(plotData))
   DataColumns <- variable.names((plotData)[DataColumnIndices])
   DataColumns
   
   DataColumnsAsName <- lapply(DataColumns,as.name)
   DataColumnsAsName

   Levels <- NULL
   if(length(LabelsAsName) > 0)
   {
      AllDataLabels <- NULL
      for( i in 1:length(LabelsAsName))
      {
         AllDataLabels <- c(AllDataLabels,as.character(eval(LabelsAsName[[i]])))
      }
      AllDataLabels
      Levels <- levels(factor(AllDataLabels))
      Levels
   }

   numDataPts <- length(eval(DataColumnsAsName[[1]]))
   numDataPts

   dimensions <- c(numDataPts,length(DataColumns))
   dimensions

   DataVector <- NULL
   LabelVector <- NULL
   ColorPermutation <- NULL
   if(length(LabelsAsName) > 0)
   {
      if( alphaSort )
      {
         for( i in 1:length(LabelsAsName))
         {
            tmp <- eval(DataColumnsAsName[[i]])[order(eval(LabelsAsName[[i]]))]
            DataVector <- c(DataVector,tmp)
            tmp <- eval(LabelsAsName[[i]])[order(eval(LabelsAsName[[i]]))]
            LabelVector <- c(LabelVector,as.character(tmp))
         }
         ColorPermutation <- match(LabelVector,Levels)
      } else
      {
         for( i in 1:length(LabelsAsName))
         {
            tmp <- eval(DataColumnsAsName[[i]])[1:length(eval(LabelsAsName[[i]]))]
            DataVector <- c(DataVector,tmp)
            tmp <- eval(LabelsAsName[[i]])[1:length(eval(LabelsAsName[[i]]))]
            LabelVector <- c(LabelVector,as.character(tmp))
         }
         ColorPermutation <- match(LabelVector,Levels)
      }
   } else
   {
      for( i in 1:length(DataColumns) )
      {
         DataVector <- c(DataVector,eval(DataColumnsAsName[[i]]))
         ColorPermutation <- c(ColorPermutation,1:numDataPts)
      }
   }
   DataVector
   LabelVector
   ColorPermutation

   r1 <- array(DataVector,dimensions)
   if( is.null(LabelVector) )
   {
      r2 <- NULL
   } else
   {
      r2 <- array(LabelVector,dimensions)
   }
   r3 <- array(ColorPermutation,dimensions)
   return(list(r1,r2,r3))
}
###########################################################
# BoxHeight
###########################################################
BarHeightXOLD <- function()
{     
         
   LabelColumnIndices <- grep(".*Label$",variable.names(plotData))
   Labels <- variable.names((plotData)[LabelColumnIndices])
   Labels
   
   LabelsAsName <- lapply(Labels,as.name)
   LabelsAsName

   DataColumnIndices <- grep(".*[^Label]$",variable.names(plotData))
   DataColumns <- variable.names((plotData)[DataColumnIndices])
   DataColumns
   
   DataColumnsAsName <- lapply(DataColumns,as.name)
   DataColumnsAsName

   Levels <- NULL
   if(length(LabelsAsName) > 0)
   {
      AllDataLabels <- NULL
      for( i in 1:length(LabelsAsName))
      {
         AllDataLabels <- c(AllDataLabels,as.character(eval(LabelsAsName[[i]])))
      }
      AllDataLabels
      Levels <- levels(factor(AllDataLabels))
      Levels
   }

   numDataPts <- length(eval(DataColumnsAsName[[1]]))
   numDataPts

   dimensions <- c(numDataPts,length(DataColumns))
   dimensions

   DataVector <- NULL
   LabelVector <- NULL
   ColorPermutation <- NULL
   if(length(LabelsAsName) > 0)
   {
      for( i in 1:length(LabelsAsName))
      {
         tmp <- eval(DataColumnsAsName[[i]])[order(eval(LabelsAsName[[i]]))]
         DataVector <- c(DataVector,tmp)
         tmp <- eval(LabelsAsName[[i]])[order(eval(LabelsAsName[[i]]))]
         LabelVector <- c(LabelVector,as.character(tmp))
      }
      ColorPermutation <- match(LabelVector,Levels)
   } else
   {
      for( i in 1:length(DataColumns) )
      {
         DataVector <- c(DataVector,eval(DataColumnsAsName[[i]]))
         ColorPermutation <- c(ColorPermutation,1:numDataPts)
      }
   }
   DataVector
   LabelVector
   ColorPermutation

   r1 <- array(DataVector,dimensions)
   if( is.null(LabelVector) )
   {
      r2 <- NULL
   } else
   {
      r2 <- array(LabelVector,dimensions)
   }
   r3 <- array(ColorPermutation,dimensions)
   return(list(r1,r2,r3))
}


###########################################################
# Relative2Axis
###########################################################
Relative2Axis <- function(axis,along,perpendicular)
{
   #along is % of the relevant axis
   #perpendicular is % of the NDC

   V <- Nndc2phy() %*% c(0,perpendicular,1)
   length <- V[2]
   u <- par("usr")
   bx <- u[2]-u[1]
   by <- u[4]-u[3]
   Busr <- NULL

   if(axis ==1)
   {
      Xusr <- bx * along + u[1]
      Yusr <- u[3]
      Andc <- Nusr2ndc() %*% c(Xusr,Yusr,1)
      Bndc <- Andc + c(0,-perpendicular,0)
      Busr <- Nndc2usr() %*% Bndc
   } else if(axis ==2)
   {
      Xusr <- u[1]
      Yusr <- by * along + u[3]
      Andc <- Nusr2ndc() %*% c(Xusr,Yusr,1)
      Bndc <- Andc + c(-perpendicular,0,0)
      Busr <- Nndc2usr() %*% Bndc
   }else
   {
      print("ERROR in Relative2Axis")
   }
   return ( c(Busr[1],Busr[2]) )
}

###########################################################
# Ntransform
###########################################################
Ntransform <- function(f,t)
{
   fXextent <- f[2] - f[1]
   tXextent <- t[2] - t[1]
   fYextent <- f[4] - f[3]
   tYextent <- t[4] - t[3]

   sx <- tXextent/fXextent
   sy <- tYextent/fYextent

   bx <- t[1]-(sx)*f[1]
   by <- t[3]-(sy)*f[3]
   a = c(sx,0,0,0,sy,0,bx,by,1)
   return (array(a,dim=c(3,3)))
}

Nusr2fig <- function()
{
   return( Ntransform(par("usr"),par("plt")))
}
Nfig2usr <- function()
{
   return(Ntransform(par("plt"),par("usr")))
}
Nfig2ndc <- function()
{
   return(Ntransform(c(0,1,0,1),par("fig")))
}
Nndc2fig <- function()
{
   return(Ntransform(par("fig"),c(0,1,0,1)))
}
Nndc2phy <- function()
{
   w <- par("din")[1]
   h <- par("din")[2]
   return(Ntransform(c(0,1,0,1),c(0,w,0,h)))
}
Nphy2ndc <- function()
{
   w <- par("din")[1]
   h <- par("din")[2]
   return(Ntransform(c(0,w,0,h),c(0,1,0,1)))
}
Nusr2phy <- function()
{
   return(Nndc2phy() %*% Nfig2ndc() %*% Nusr2fig())
}
Nphy2usr <- function()
{
   return(Nfig2usr() %*% Nndc2fig() %*% Nphy2ndc())
}
Nusr2ndc <- function()
{
   return ( Nfig2ndc() %*% Nusr2fig() )
}
Nndc2usr <- function()
{
   return ( Nfig2usr() %*% Nndc2fig() )
}


###########################################################
# my.text.width.height
###########################################################
# returns the width & height of the box bounding the text
# also returns the y offsets for plotting the labels
#
# labels - vector of strings
# spacing - % of character height
###########################################################
my.text.width.height <- function(labels,spacing)
{
   wv <- NULL
   for(i in 1:length(labels)){wv[i] <- strwidth(labels[i])}
   W <- max(wv)
   h <- strheight("X");
   H <- h * length(labels) + (length(labels)-1) * h * spacing
   y <- NULL
   y[1] <- -h
   for(i in 2:length(labels))
   {
      y[i] <- y[i-1] -( h + h * spacing )
   }
   return(list(width=W,height=H,y.offsets=y))
}
###########################################################
# my.text
###########################################################
# displays text labels on a plot; returns the bounding
# box coordinates as a list
#
# x - x coordinate
# y - y coordinate
# labels - the text strings to plot
# spacing - vertical spacing between lines
# adj - one or two values in [0,1] which specify 
#       the x (and optionally y) adjustment of the labels
# box.adj - adjustment to the whole body (box) of text
# plot - enable plotting
###########################################################
my.text <- function(x,y,labels,spacing=0.5,adj,box.adj=c(0.5,0.5),plot=TRUE)
{
   print("my.text")
   print(paste("plot=",plot))
   print(paste("x=",x))
   print(paste("y=",y))
   box <- my.text.width.height(labels,spacing)
   print(paste("box#width=",box$width))
   print(paste("box#height=",box$height))
   print(paste("box#y.offsets=",box$y.offsets))
   y0 <- y + box.adj[2] * box$height
   x0 <- x - box.adj[1] * box$width
   yVec <- y0 + box$y.offsets
   xVec <- rep(x0,length(yVec))
   if(plot)
   {
      text(x=xVec,y=yVec,labels=labels,adj=adj)
   }

   #abline(v=x0)
   #abline(v=x0 + box$width)
   #abline(h=y0)
   #abline(h=y0 - box$height)
   return(list(xleft=x0,ybottom=y0 - box$height,xright=x0 + box$width,ytop=y0))
}
###########################################################
# my.text2
###########################################################
# displays text labels on a plot; returns the bounding
# box coordinates as a list
#
# x - x coordinate
# y - y coordinate
# labels - the text strings to plot
# spacing - vertical spacing between lines
# adj - one or two values in [0,1] which specify 
#       the x (and optionally y) adjustment of the labels
# box.adj - adjustment to the whole body (box) of text
# plot - enable plotting
###########################################################
my.text2 <- function(x,y,box,labels,adj,box.adj=c(0.5,0.5),plot=TRUE)
{
   print("my.text")
   print(paste("plot=",plot))
   print(paste("x=",x))
   print(paste("y=",y))
   y0 <- y + box.adj[2] * box$height
   x0 <- x - box.adj[1] * box$width
   yVec <- y0 + box$y.offsets
   xVec <- rep(x0,length(yVec))
   if(plot)
   {
      text(x=xVec,y=yVec,labels=labels,adj=adj)
   }

   #abline(v=x0)
   #abline(v=x0 + box$width)
   #abline(h=y0)
   #abline(h=y0 - box$height)
   return(list(xleft=x0,ybottom=y0 - box$height,xright=x0 + box$width,ytop=y0))
}
###########################################################
# my.text.bordered
###########################################################
# plots bordered text labels; returns the boundary of the
# box
#
# x - x coordinate
# y - y coordinate
# labels - the text strings to plot
# sp - vertical spacing between lines
# adj - one or two values in [0,1] which specify 
#       the x (and optionally y) adjustment of the labels
# box.adj - adjustment to the whole body (box) of text
# insets - padding as list(xleft,ybottom,xright,ytop)
# fill.col - background fill color
# border.col - border color
# lty - line type of border
# lwd - line width of border
# plot - enable plotting
###########################################################
my.text.bordered <- function(x,y,labels,sp=0.5,adj,box.adj=c(0.5,0.5),insets,fill.col,border.col,lty,lwd,plot=TRUE)
{
print(paste("x=",x))
print(paste("y=",y))
   tBox <- my.text(x,y,labels,sp,adj,box.adj=box.adj,plot=FALSE)
   boundary <- my.text.box(tBox,insets,fill.col,border.col,lty,lwd,plot)
   my.text(x,y,labels,sp,adj,box.adj=box.adj,plot=plot)
}
###########################################################
# my.box
###########################################################
# draws filled rectangle then adds text
# returns the boundary of the rectangle
#
# tBox - coordinate of text as list(xleft,ybottom,xright,ytop)
# col - background fill color
# border.col - border color
# lty - line type of border
# lwd - line width of border
# plot - enable plotting
###########################################################
my.box <- function(tBox,col,border.col,lty,lwd,plot)
{
   xleft <- tBox$xleft
   ybottom <- tBox$ybottom
   xright <- tBox$xright
   ytop <- tBox$ytop
   if(plot)
   {
      rect(xleft,ybottom,xright,ytop,col=col,border=border.col,lty=lty,lwd=lwd)
   }
   return(list(xleft=xleft,ybottom=ybottom,xright=xright,ytop=ytop))
}
###########################################################
# my.print.summary.lm
###########################################################
# x - summary(linaer.regression)
# digits - significate digits
# enable - boolean list(eq,resid,coef,coef.std.err,coef.t.val,
#      coef.p.val,resid.std.err,multi.r.sqr,adj.r.sqr,f.stat)
###########################################################
my.print.summary.lm <-
function (x, digits = 3, symbolic.cor = x$symbolic.cor,
   enable, signif.stars = FALSE, ...)
{
    sig = digits
    sp1 <- "  "
    sp2 <- "    "
    sp3 <- "      "
    rtrn <- NULL;
    coefs <- signif(x$coefficients,sig);
    b.intercept <- coefs[1,1]
    m.slope <- coefs[2,1]
    if(enable$eq)
    {
       rtrn <- paste(rtrn,"y=",m.slope,"x+",b.intercept,"\n",sep="")
    }
#    cat("\nCall:\n")
#    cat(paste(deparse(x$call), sep = "\n", collapse = "\n"),
#        "\n\n", sep = "")
    resid <- x$residuals
    df <- x$df
    rdf <- df[2]
    if(enable$resid)
    {
       rtrn <- paste(rtrn,sp1,if (!is.null(x$w) && diff(range(x$w)))
           "Weighted ", "Residuals:\n", sep = "")
    }
    rtrn <- paste(rtrn,sp2,sep="")
    if (rdf > 5) {
        nam <- c("Min", "1Q", "Median", "3Q", "Max")
        rq <- if (length(dim(resid)) == 2)
            structure(apply(t(resid), 1, quantile), dimnames = list(nam,
                dimnames(resid)[[2]]))
        else structure(quantile(resid), names = nam)
#        print(rq, digits = digits, ...)
       if(enable$resid)
       {
          for(i in 1:length(rq)){rtrn <- paste(rtrn,nam[i],"=",rq[i])}
       }
    }
    else if (rdf > 0) {
#        print(resid, digits = digits, ...)
       if(enable$resid)
       {
          for(i in 1:length(resid)){rtrn <- paste(rtrn,signif(as.vector(resid)[i],3))}
          rtrn <- paste(rtrn,"\n",sep = "")
       }
    }
    else {
#        cat("ALL", df[1], "residuals are 0: no residual degrees of freedom!\n")
       if(enable$resid)
       {
          rtrn <- paste(rtrn,"ALL", df[1], "residuals are 0: no residual degrees of freedom!\n",sep="")
       }
    }
    if (length(x$aliased) == 0) {
#        cat("\nNo Coefficients\n")
        if(enable$coef)
        {
           rtrn <- paste(rtrn,"\nNo Coefficients\n",sep="")
        }
    }
    else {
        if (nsingular <- df[3] - df[1])
        {
            if(enable$coef)
            {
               rtrn <- paste(rtrn,sp1,sep="")
               rtrn <- paste(rtrn,"\nCoefficients: (", nsingular, " not defined because of singularities)\n",
                   sep = "")
            }
        }
        else
        {
            if(enable$coef)
            {
               rtrn <- paste(rtrn,sp1,"Coefficients:\n",sep="")
            }
        }
#        coefs <- x$coefficients
        if (!is.null(aliased <- x$aliased) && any(aliased)) {
            cn <- names(aliased)
            coefs <- matrix(NA, length(aliased), 4, dimnames = list(cn,
                colnames(coefs)))
            coefs[!aliased, ] <- x$coefficients
        }
#        printCoefmat(coefs, digits = digits, signif.stars = signif.stars,
#            na.print = "NA", ...)
       if(enable$coef)
       {
          rtrn <- paste(rtrn,sp2,"Intercept:\n",sep="")
          rtrn <- paste(rtrn,sp3,"Estimate=",coefs[1,1],"\n",sep="")
          if(enable$coef.std.err)
          {
             rtrn <- paste(rtrn,sp3,"Std. Error=",coefs[1,2],"\n",sep="")
          }
          if(enable$coef.t.value)
          {
             rtrn <- paste(rtrn,sp3,"t value=",coefs[1,3],"\n",sep="")
          }
          if(enable$coef.p.value)
          {
             rtrn <- paste(rtrn,sp3,"Pr(>|t|)=",coefs[1,4],"\n",sep="")
          }
          rtrn <- paste(rtrn,sp2,"Slope:\n",sep="")
          rtrn <- paste(rtrn,sp3,"Estimate=",coefs[2,1],"\n",sep="")
          if(enable$coef.std.err)
          {
             rtrn <- paste(rtrn,sp3,"Std. Error=",coefs[2,2],"\n",sep="")
          }
          if(enable$coef.t.value)
          {
             rtrn <- paste(rtrn,sp3,"t value=",coefs[2,3],"\n",sep="")
          }
          if(enable$coef.p.value)
          {
             rtrn <- paste(rtrn,sp3,"Pr(>|t|)=",coefs[2,4],"\n",sep="")
          }
       }
    }
    if(enable$resid.std.err)
    {
       rtrn <- paste(rtrn,"\nResidual standard error:", format(signif(x$sigma,
           digits)), "on", rdf, "degrees of freedom\n",sep="")
    }
    if(enable$f.statistics)
    {
       if (!is.null(x$fstatistic)) {
           rtrn <- paste(rtrn,"Multiple R-Squared:", formatC(x$r.squared, digits = digits),"\n",sep="")
           rtrn <- paste(rtrn,"Adjusted R-squared:", formatC(x$adj.r.squared,
               digits = digits), "\nF-statistic:", formatC(x$fstatistic[1],
               digits = digits), "on", x$fstatistic[2], "and", x$fstatistic[3],
               "DF,  p-value:", format.pval(pf(x$fstatistic[1],
                   x$fstatistic[2], x$fstatistic[3], lower.tail = FALSE),
                   digits = digits), "\n",sep="")
       }
    }
    return(rtrn)
}
###########################################################
# split.text
###########################################################
split.text <- function(txtStr)
{
   labels <- strsplit(txtStr,split="\n")
   return(labels[[1]])
}
###########################################################
# add.box.insets
###########################################################
add.box.insets <-function(box,insets)
{
   l <- box$xleft - insets$xleft
   r <- box$xright + insets$xright
   t <- box$ytop + insets$ytop
   b <- box$ybottom - insets$ybottom
   return(list(xleft=l,xright=r,ytop=t,ybottom=b))
}
###########################################################
# draw.box
###########################################################
draw.box <- function(box,col,border.col,lty,lwd,plot)
{
   xleft <- box$xleft
   ybottom <- box$ybottom
   xright <- box$xright
   ytop <- box$ytop
   if(plot)
   {
      rect(xleft,ybottom,xright,ytop,col=col,border=border.col,lty=lty,lwd=lwd)
   }
   return(box)
}
###########################################################
# box.boundary
###########################################################
box.boundary <- function(xy,box,xj,yj)
{
   x <- xy[1]
   y <- xy[2]
   w <- box$width
   h <- box$height
   L <- x + xj * w - w
   R <- x + xj * w
   B <- y + yj * h - h
   T <- y + yj * h
   return(list(xleft=L,ybottom=B,xright=R,ytop=T))
}

###########################################################
# TornadoPlot
###########################################################
# cv - color
# zv - border color
# hx - height matrix
# wv - width
# sv - space
# xl - x limit vector
# yl - y limit vector
# pt - plot flag
# b1 - lty vector for border
# b2 - lwd vector for border
###########################################################
TornadoPlot <- function(cv,zv,hx,wv,sv,xl,yl,pt,b1,b2)
{
   absHX <- abs(hx)
   o <- order(absHX)
   hxOrdered <- hx[o]

   mx <- barplot(height=hxOrdered,ann=F,axes=F,horiz=T,
       width=wv,space=sv,beside=T,plot=F)
print(paste("mx=",mx))

   #=======================================================
   #determine the x axis limits
   #
   if(is.null(xl))
   {
      xl <- c(-max(abs(hx)),max(abs(hx)))
   }

   #=======================================================
   #determine the y axis limits
   #
   if(is.null(yl))
   {
      yl <- c(min(mx),max(mx))
   }

   #=======================================================
   #set up the plotting area
   #
   matplot(add=F,ann=F,axes=F,type="n",x=xl,y=yl)

   for( i in 1:length(mx))
   {
      x1 <- 0
      y1 <- mx[i] - wv/2 
      x2 <- hxOrdered[i]
      y2 <- mx[i] + wv/2
      rect(x1,y1,x2,y2,col=cv,border=zv,lty=b2,lwd=b2)
   }

   abline(v=0)

   return(list(mx=mx,hx=hxOrdered,order=o));
}

###########################################################
# TornadoLabels
###########################################################
TornadoLabels <- function(mx, hx, lb)
{
   for( i in 1:length(mx))
   {
      y <- mx[i];
      x <- -sign(hx[i]) * strwidth(lb[i])
      text(x=x,y=y,labels=lb[i])
   }
}







